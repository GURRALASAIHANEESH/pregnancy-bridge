"""
MedGemma Prompt Template
Structured prompts for clinical explanation generation
Author: PregnancyBridge Development Team
Version: 2.0.0
Date: 2026-02-04
"""

from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)


# ============================================================================
# NEW: Context Interpreter & Missing Data Recommender Prompts (Feb 6, 2026)
# ============================================================================

# ─── Prompt design notes ────────────────────────────────────────────────────
# • Ends with "Clinical explanation:" so the model continues in prose — the
#   first generated token cannot accidentally match a stop sequence.
# • Numbered instructions are GONE from the body; the task is stated as a
#   single direct directive before the completion cue.
# • Kept short (~150-200 tokens) to leave generation budget even on n_ctx=2048.
# ─────────────────────────────────────────────────────────────────────────────
CONTEXT_INTERPRETER_PROMPT = """You are a clinical support tool. A rule-based maternal risk engine classified this case as {risk_category}.

Key findings: {evidence_summary}
Symptoms reported: {symptoms}
Rule trigger: {rule_reason}

In 2-3 concise sentences, explain why these findings support the {risk_category} classification and what complication this presentation aims to prevent. Do not change the risk level.

Clinical explanation:"""

MISSING_DATA_PROMPT = """ROLE: field-safe next-action recommender.
INPUT:
- evidence_summary: {evidence_summary}
- available_tests: {available_tests}
- context: {context}

TASK:
Return a JSON array (max 3) of objects:
{{ "action":"<action_code>", "priority":"urgent|near-term|follow-up", "why":"short clinical reason", "practical_note":"one-line field advice" }}
Prioritize actions feasible for ASHA (phone call, arrange transport, refer, repeat basic tests).
If you cannot produce valid JSON, return the deterministic fallback action: {{"action":"refer","priority":"urgent","why":"insufficient_data - safety-first"}}.

OUTPUT: JSON only.
"""

FALLBACK_EXPLANATION_TEMPLATE = """Explanation (fallback): Evidence: {evidence_summary}. Rule-based decision: {risk_category}. Reason: {rule_reason}. If urgent, refer to facility. Explanation autogenerated by fallback."""


class MedGemmaPromptTemplate:
    """
    Generates structured prompts for MedGemma clinical reasoning.
    
    Production features:
    - Explicit risk category preservation instruction
    - Evidence-grounded reasoning
    - Concise output constraints
    - Temporal trend integration
    
    Design rationale:
    MedGemma must explain WHY the rule engine escalated, not override it.
    Prompts are designed to elicit evidence-based clinical reasoning that
    respects the deterministic risk classification.
    """
    
    def __init__(self):
        """Initialize prompt template generator."""
        logger.info("MedGemmaPromptTemplate v2.0 initialized")
    
    def generate_clinical_explanation_prompt(self,
                                            risk_category: str,
                                            trigger_reason: str,
                                            evidence_summary: List[str],
                                            visits: List[Dict],
                                            symptoms: Optional[Dict] = None) -> str:
        """
        Generate prompt for MedGemma clinical explanation.
        
        This prompt MUST be used exactly as specified in requirements.
        MedGemma is instructed to explain, not override, the risk classification.
        
        Args:
            risk_category: 'LOW', 'MODERATE', or 'HIGH'
            trigger_reason: Risk engine trigger reason
            evidence_summary: List of evidence statements
            visits: Visit records
            symptoms: Symptom dictionary
            
        Returns:
            Formatted prompt string
        """
        prompt_parts = []
        
        # Header instruction
        prompt_parts.append("A rule-based maternal risk system has escalated this case.")
        prompt_parts.append("")
        
        # Risk classification (fixed by rule engine)
        prompt_parts.append(f"Risk category: {risk_category}")
        prompt_parts.append(f"Trigger reason: {trigger_reason}")
        prompt_parts.append("")
        
        # Evidence summary
        prompt_parts.append("Evidence summary:")
        for i, evidence in enumerate(evidence_summary, 1):
            prompt_parts.append(f"{i}. {evidence}")
        prompt_parts.append("")
        
        # Patient visit timeline
        prompt_parts.append("Patient visit timeline:")
        prompt_parts.extend(self._format_visit_timeline(visits))
        prompt_parts.append("")
        
        # Reported symptoms
        if symptoms and symptoms.get('present_symptoms'):
            prompt_parts.append("Reported symptoms:")
            symptom_list = ', '.join(symptoms['present_symptoms'])
            prompt_parts.append(symptom_list)
            prompt_parts.append("")
        
        # Instructions for the model (EXACT as per requirement)
        prompt_parts.append("Instructions for the model:")
        prompt_parts.append("- Mention each evidence item explicitly.")
        prompt_parts.append("- Explain how the combination of lab trends and symptoms supports the escalation.")
        prompt_parts.append("- Do NOT change the provided risk_category.")
        prompt_parts.append("- Use concise clinical language (3-6 sentences).")
        
        prompt = "\n".join(prompt_parts)
        
        logger.debug(f"Generated prompt: {len(prompt)} chars, risk={risk_category}")
        
        return prompt
    
    def _format_visit_timeline(self, visits: List[Dict]) -> List[str]:
        """
        Format visit timeline for prompt.
        
        Args:
            visits: List of visit records
            
        Returns:
            List of formatted visit strings
        """
        lines = []
        
        for i, visit in enumerate(visits, 1):
            parts = []
            
            # Visit number and date
            visit_label = f"Visit {i}"
            if visit.get('date'):
                visit_label += f" ({visit['date']})"
            
            # Gestational age
            if visit.get('gestational_age'):
                parts.append(f"GA {visit['gestational_age']} weeks")
            
            # Blood pressure
            if visit.get('bp'):
                bp = visit['bp']
                if bp.get('systolic') and bp.get('diastolic'):
                    parts.append(f"BP {bp['systolic']}/{bp['diastolic']}")
            
            # Hemoglobin
            if visit.get('hemoglobin') is not None:
                parts.append(f"Hb {visit['hemoglobin']} g/dL")
            
            # Platelets
            if visit.get('platelets') is not None:
                parts.append(f"Plt {visit['platelets']:,}")
            
            # Proteinuria
            if visit.get('proteinuria'):
                parts.append(f"Protein {visit['proteinuria']}")
            
            # WBC
            if visit.get('wbc') is not None:
                parts.append(f"WBC {visit['wbc']:,}")
            
            # Combine
            if parts:
                lines.append(f"{visit_label}: {', '.join(parts)}")
            else:
                lines.append(visit_label)
        
        return lines
    
    def generate_differential_diagnosis_prompt(self,
                                               clinical_presentation: str,
                                               lab_findings: List[str]) -> str:
        """
        Generate prompt for differential diagnosis generation.
        
        Args:
            clinical_presentation: Summary of clinical presentation
            lab_findings: List of lab abnormalities
            
        Returns:
            Formatted prompt string
        """
        prompt_parts = []
        
        prompt_parts.append("Generate differential diagnoses for this maternal case:")
        prompt_parts.append("")
        prompt_parts.append(f"Clinical presentation: {clinical_presentation}")
        prompt_parts.append("")
        
        if lab_findings:
            prompt_parts.append("Laboratory findings:")
            for finding in lab_findings:
                prompt_parts.append(f"- {finding}")
            prompt_parts.append("")
        
        prompt_parts.append("List top 3-5 differential diagnoses with brief justification for each.")
        prompt_parts.append("Format: [Diagnosis]: [1-2 sentence justification]")
        
        return "\n".join(prompt_parts)
    
    def generate_management_recommendation_prompt(self,
                                                  risk_category: str,
                                                  clinical_summary: str) -> str:
        """
        Generate prompt for management recommendations.
        
        Args:
            risk_category: Risk classification
            clinical_summary: Brief clinical summary
            
        Returns:
            Formatted prompt string
        """
        prompt_parts = []
        
        prompt_parts.append(f"Patient risk category: {risk_category}")
        prompt_parts.append(f"Clinical summary: {clinical_summary}")
        prompt_parts.append("")
        prompt_parts.append("Provide evidence-based management recommendations:")
        prompt_parts.append("1. Immediate interventions")
        prompt_parts.append("2. Referral timing and level")
        prompt_parts.append("3. Monitoring parameters")
        prompt_parts.append("4. Patient counseling points")
        prompt_parts.append("")
        prompt_parts.append("Keep response concise (4-8 sentences).")
        
        return "\n".join(prompt_parts)
    
    def validate_prompt_constraints(self, prompt: str) -> Dict:
        """
        Validate that prompt meets quality constraints.
        
        Args:
            prompt: Generated prompt string
            
        Returns:
            Validation result dictionary
        """
        issues = []
        
        # Check length
        if len(prompt) < 100:
            issues.append("Prompt too short")
        elif len(prompt) > 2000:
            issues.append("Prompt too long (may exceed model context)")
        
        # Check required components
        required_phrases = [
            "rule-based",
            "Risk category:",
            "Evidence summary:",
            "Do NOT change"
        ]
        
        for phrase in required_phrases:
            if phrase not in prompt:
                issues.append(f"Missing required phrase: '{phrase}'")
        
        # Check risk category preservation instruction
        if "Do NOT change the provided risk_category" not in prompt:
            issues.append("Missing explicit risk category preservation instruction")
        
        is_valid = len(issues) == 0
        
        logger.debug(f"Prompt validation: {'PASS' if is_valid else 'FAIL'} ({len(issues)} issue(s))")
        
        return {
            'valid': is_valid,
            'issues': issues,
            'length': len(prompt)
        }


# Singleton
_prompt_template_instance = None


def get_prompt_template() -> MedGemmaPromptTemplate:
    """Get singleton instance of MedGemmaPromptTemplate."""
    global _prompt_template_instance
    if _prompt_template_instance is None:
        _prompt_template_instance = MedGemmaPromptTemplate()
    return _prompt_template_instance


# Self-test
if __name__ == "__main__":
    print("\n" + "=" * 70)
    print("MedGemmaPromptTemplate v2.0 Self-Test")
    print("=" * 70)
    
    template = get_prompt_template()
    
    # Test 1: Clinical explanation prompt
    print("\nTest 1: Clinical Explanation Prompt")
    print("-" * 70)
    
    test_visits = [
        {
            'date': '2026-01-10',
            'gestational_age': 32,
            'bp': {'systolic': 138, 'diastolic': 88},
            'hemoglobin': 11.2,
            'platelets': 180000,
            'proteinuria': 'trace'
        },
        {
            'date': '2026-02-04',
            'gestational_age': 36,
            'bp': {'systolic': 150, 'diastolic': 96},
            'hemoglobin': 10.5,
            'platelets': 85000,
            'proteinuria': '+2'
        }
    ]
    
    test_evidence = [
        "platelets dropped 180000→85000 (drop 53%)",
        "proteinuria progressed trace→+2",
        "new neurological symptoms (headache, blurred vision)"
    ]
    
    test_symptoms = {
        'present_symptoms': ['headache', 'blurred_vision']
    }
    
    prompt = template.generate_clinical_explanation_prompt(
        risk_category='HIGH',
        trigger_reason='Platelet drop with proteinuria and neurological symptoms',
        evidence_summary=test_evidence,
        visits=test_visits,
        symptoms=test_symptoms
    )
    
    print(prompt)
    print(f"\nPrompt length: {len(prompt)} chars")
    
    # Test 2: Prompt validation
    print("\nTest 2: Prompt Validation")
    print("-" * 70)
    
    validation = template.validate_prompt_constraints(prompt)
    print(f"Valid: {validation['valid']}")
    print(f"Length: {validation['length']} chars")
    if validation['issues']:
        print("Issues:")
        for issue in validation['issues']:
            print(f"  - {issue}")
    else:
        print("No issues found")
    
    # Test 3: Differential diagnosis prompt
    print("\nTest 3: Differential Diagnosis Prompt")
    print("-" * 70)
    
    dd_prompt = template.generate_differential_diagnosis_prompt(
        clinical_presentation="36-week pregnant woman with elevated BP, proteinuria, and severe thrombocytopenia",
        lab_findings=[
            "BP 150/96 mmHg",
            "Platelets 85,000/uL",
            "Proteinuria +2"
        ]
    )
    
    print(dd_prompt)
    
    # Test 4: Management recommendation prompt
    print("\nTest 4: Management Recommendation Prompt")
    print("-" * 70)
    
    mgmt_prompt = template.generate_management_recommendation_prompt(
        risk_category='HIGH',
        clinical_summary='Preeclampsia with severe features (HELLP pattern)'
    )
    
    print(mgmt_prompt)
    
    print("\n" + "=" * 70)
    print("✓ All self-tests passed")
    print("=" * 70)
